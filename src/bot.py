import logging
import threading
import time
import datetime
import os
from collections import defaultdict
from functools import wraps
from typing import Callable
from dotenv import load_dotenv

import asyncio
import sentry_sdk
from aiogram import Bot, Dispatcher, executor, types
from aiogram.dispatcher.filters import Command, IDFilter
from aiogram.dispatcher.filters.filters import AndFilter

from src.constants import (
    ADMIN_IDS,  # –ù—É–∂–Ω–æ –±—É–¥–µ—Ç –≤—Å—Ç–∞–≤–∏—Ç—å —Ç—É–¥–∞ —Å–≤–æ–π id
    COMMAND_HELP,
    COMMAND_ROLL,
    COMMAND_START,
    COMMAND_STATS,
    COMMAND_USER,
    COMMAND_GAME_LEADERS,
    COMMAND_ROUND_LEADERS,
    COMMAND_LAUNCH_SECONDS,
    COMMAND_LAUNCH_TIME,
    COMMAND_QUESTION,
    COMMAND_PRIZE
)
from src.leaderboard import LeaderBoard
from src.utils.logs import async_log_exception, pretty_time_delta
from src.utils.misc import prepare_str

logging.basicConfig(
    level=logging.DEBUG,
)
log = logging.getLogger(__name__)

load_dotenv()
launched = False  # –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è = –∑–∞–ø—É—â–µ–Ω –ª–∏ —Ä–∞—É–Ω–¥, –Ω–µ –¥–∞–µ—Ç —Å–¥–µ–ª–∞—Ç—å roll –¥–æ —Ä–∞—É–Ω–¥–∞
messages = []   # –°–ø–∏—Å–æ–∫ —Ö—Ä–∞–Ω–∏—Ç id —Å–æ–æ–±—â–µ–Ω–∏–π roll–æ–≤ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤, –≤ —Ü–µ–ª–æ–º –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –∏ id
# times = [] - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–¥–µ–ª–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ –ø–æ –∫–Ω–æ–ø–∫–∞–º
API_TOKEN = os.getenv('TOKEN')
SUBS_CHAT_ID = os.getenv('CHAT_ID')
duration = 0  # –î–ª–∏–Ω–∞ —Ä–∞—É–Ω–¥–∞
prizewinners = 5  # –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø—Ä–∏–∑–æ–≤—ã—Ö –º–µ—Å—Ç


class Manager:
    def __init__(self, token: str, sentry_token: str = None):
        self.bot = Bot(
            token=token,
            timeout=3.0,
        )
        self.dispatcher = Dispatcher(
            bot=self.bot,
        )
        sentry_sdk.init(
            dsn=sentry_token,
            traces_sample_rate=1.0,
        )

        # Game rules
        self.board = LeaderBoard()

        # Runtime stats
        self.counter = 0
        self.unique_chats = set()
        self.started_at = time.time()
        self.func_counter = defaultdict(int)
        self.func_average_resp_time = defaultdict(float)  # milliseconds
        self.func_resp_time = defaultdict(list)  # milliseconds
        self.max_list_size = 1000

    async def on_shutdown(self, dispatcher: Dispatcher):
        log.debug('Dump data')
        self.board.dump_data()

    def run(self):
        self.set_up_commands()

        # self.board.run_update()

        executor.start_polling(
            dispatcher=self.dispatcher,
            skip_updates=True,
            on_shutdown=self.on_shutdown,
        )

    def increment_counter(self, f):
        """Wrap any important function with this."""

        @wraps(f)
        async def inner(message: types.Message, *args, **kwargs):
            fn = f.__name__
            self.counter += 1
            self.func_counter[fn] += 1

            # Calculate response time
            t0 = time.time()
            res = await f(*args, message, **kwargs)
            dt = (time.time() - t0) * 1000
            self.func_average_resp_time[fn] += dt

            # Store only last X values
            self.func_resp_time[fn] = self.func_resp_time[fn][-(self.max_list_size - 1):]
            self.func_resp_time[fn].append(dt)

            chat_id = message.chat.id
            self.unique_chats.add(chat_id)

            return res

        return inner

    def set_up_commands(self):
        self.dispatcher.register_message_handler(
            self.increment_counter(self.show_welcome),
            Command(commands=[COMMAND_START]),
        )
        self.dispatcher.register_message_handler(
            self.increment_counter(self.show_help),
            Command(commands=[COMMAND_HELP]),
        )
        self.dispatcher.register_message_handler(
            self.increment_counter(self.question),
            Command(commands=[COMMAND_QUESTION]),
        )

        # –ò–≥—Ä–∞
        self.dispatcher.register_message_handler(
            self.increment_counter(self.roll_once),
            Command(commands=[COMMAND_ROLL]),
        )
        self.dispatcher.register_message_handler(
            self.increment_counter(self.roll_stats_round),
            Command(commands=[COMMAND_ROUND_LEADERS]),
        )
        self.dispatcher.register_message_handler(
            self.increment_counter(self.roll_stats_total),
            Command(commands=[COMMAND_GAME_LEADERS]),
        )

        # –ü—Ä–æ—á–∏–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã, admin only
        self.dispatcher.register_message_handler(
            self.show_user_info,
            AndFilter(
                Command(commands=[COMMAND_USER]),
                IDFilter(chat_id=ADMIN_IDS),
            ),
        )
        self.dispatcher.register_message_handler(
            self.show_stats,
            AndFilter(
                Command(commands=[COMMAND_STATS]),
                IDFilter(chat_id=ADMIN_IDS),
            ),
        )
        self.dispatcher.register_message_handler(
            self.launch_bot_seconds,
            AndFilter(
                Command(commands=[COMMAND_LAUNCH_SECONDS]),
                IDFilter(chat_id=ADMIN_IDS),
            ),
        )
        self.dispatcher.register_message_handler(
            self.launch_bot_time,
            AndFilter(
                Command(commands=[COMMAND_LAUNCH_TIME]),
                IDFilter(chat_id=ADMIN_IDS),
            ),
        )
        self.dispatcher.register_message_handler(
            self.set_prizewinners,
            AndFilter(
                Command(commands=[COMMAND_PRIZE]),
                IDFilter(chat_id=ADMIN_IDS),
            ),
        )
        # self.dispatcher.callback_query_handler()

    @async_log_exception
    async def show_welcome(self, message: types.Message):
        global launched
        launched = False
        user_channel_status = await m.bot.get_chat_member(chat_id=SUBS_CHAT_ID, user_id=message.chat.id)
        print(user_channel_status['status'])  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É. –ú–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ —Ñ—É–Ω–∫—Ü–∏—é –∏ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –µ—â–µ —Ä–∞–∑ –ø—Ä–∏ –±—Ä–æ—Å–∫–µ
        if user_channel_status['status'] != 'left':
            text = [
                '–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –±–æ—Ç –¥–ª—è –±—Ä–æ—Å–∞–Ω–∏—è —à–∞—Ä–æ–≤. –ö–∞–∂–¥—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –±—Ä–æ—Å–∏—Ç—å —à–∞—Ä—ã —Ç–æ–ª—å–∫–æ 1 —Ä–∞–∑ –∑–∞ —Ä–∞—É–Ω–¥.',
                '–ß–µ–º –±–æ–ª—å—à–µ *–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ* –≤—ã–ø–∞–≤—à–∏—Ö –∫–µ–≥–ª—å - —Ç–µ–º –ª—É—á—à–µ.',
                '',
                f'–ù–∞–∂–º–∏—Ç–µ /{COMMAND_HELP} —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–º–º–∞–Ω–¥.',
                '',
                f'–ó–∞–¥–∞–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å: /{COMMAND_QUESTION} –í–∞—à –≤–æ–ø—Ä–æ—Å.',
                '',
                f'–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /{COMMAND_ROLL} —á—Ç–æ–±—ã —Å—Ä–∞–∑—É –±—Ä–æ—Å–∏—Ç—å —à–∞—Ä—ã.',
            ]
        else:
            text = ["–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º!"]
        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )

    @async_log_exception
    async def question(self, message: types.Message):
        question = str(message.get_args())
        await message.answer("–í–∞—à –≤–æ–ø—Ä–æ—Å –±—ã–ª –ø–µ—Ä–µ–¥–∞–Ω –∞–¥–º–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É, –æ–∂–∏–¥–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∞!", parse_mode=types.ParseMode.MARKDOWN)
        for admin in ADMIN_IDS:
            await m.bot.send_message(chat_id=admin, text=f"–í–æ–ø—Ä–æ—Å –æ—Ç {message.chat.id}: {question}")
            # –•–∑, –º–æ–∂–Ω–æ –ª–∏ –ø–æ id –Ω–∞–ø–∏—Å–∞—Ç—å —á–µ–ª–æ–≤–µ–∫—É, –µ—Å–ª–∏ –Ω–µ—Ç, –Ω–∞–¥–æ —á—É—Ç—å –ø–µ—Ä–µ–¥–µ–ª–∞—Ç—å

    @async_log_exception
    async def roll_once(self, message: types.Message):
        global launched
        chat_id = message.chat.id
        dt = self.board.time_left
        if not launched:
            text = [
                f'*–ò–≥—Ä–∞ –µ—â–µ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞!*',
                '',
            ]
            return await message.answer(
                text=prepare_str(text=text),
                parse_mode=types.ParseMode.MARKDOWN,
            )

        if not self.board.can_add_result(chat_id=chat_id):
            text = [
                f'*–í—ã —É–∂–µ –ø—Ä–∏–Ω—è–ª–∏ —É—á–∞—Å—Ç–∏–µ!*',
                '',
            ]
            # –ü–æ—Å—á–∏—Ç–∞—Ç—å —Ç–æ—á–Ω–æ–µ –≤—Ä–µ–º—è
            # if dt < 0:
            # –ß—Ç–æ-—Ç–æ –Ω–µ —Ç–∞–∫ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º!
            # msg = '–í—ã —Å–∫–æ—Ä–æ —Å–º–æ–∂–µ—Ç–µ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å!'
            # log.error('something wrong with update thread!')
            # else:
            # msg = f'–í—ã —Å–º–æ–∂–µ—Ç–µ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –≤ –Ω–æ–≤–æ–º —Ä–∞—É–Ω–¥–µ —á–µ—Ä–µ–∑ {pretty_time_delta(dt)}!'
            # text.append(msg)

            return await message.answer(
                text=prepare_str(text=text),
                parse_mode=types.ParseMode.MARKDOWN,
            )
        if dt < 0:
            text = [
                f'*–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω!*',
                f'–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –í—ã –Ω–µ —É—Å–ø–µ–ª–∏ –ø—Ä–∏–Ω—è—Ç—å —É—á–∞—Å—Ç–∏–µ',
                '',
            ]
            return await message.answer(
                text=prepare_str(text=text),
                parse_mode=types.ParseMode.MARKDOWN,
            )
        # Roll
        rolls = [await message.answer_dice(emoji='üé≥') for _ in range(3)]

        messages.append(message)

        score = 1
        for v in rolls:
            score *= v["dice"]["value"]

        # Wait for animation
        await asyncio.sleep(3)

        pos = self.board.add_result(
            chat_id=chat_id,
            full_name=message.chat.full_name,
            score=score,
        )

        text = [
            f'–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: *{score}*',
            f'–ü—Ä—è–º–æ —Å–µ–π—á–∞—Å –≤—ã –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ *{pos}*',
            '',
            f'–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Ç–æ–≥–∏ —Ä–∞—É–Ω–¥–∞: /{COMMAND_ROUND_LEADERS}',
            # f'–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ª—É—á—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã: /{COMMAND_GAME_LEADERS}',
        ]
        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )

    async def abc_roll_stats_round(self, stats_func: Callable, header: str, message: types.Message):
        chat_id = message.chat.id
        stats = stats_func(chat_id=chat_id)
        if not stats:
            return await message.answer(
                text='–ü–æ–∫–∞ —á—Ç–æ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç.',
                parse_mode=types.ParseMode.MARKDOWN,
            )

        text = [
            header,
            '',
        ]

        for pos, item in stats:
            msg_pos = f'*{pos}*' if pos <= 3 else f'{pos}'
            msg = f'{msg_pos}. {item}'
            text.append(msg)

        dt = self.board.time_left
        if dt > 0:
            text.extend([
                '',
                f'–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —á–µ—Ä–µ–∑: {pretty_time_delta(dt)}',
            ])

        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )

    @async_log_exception
    async def roll_stats_round(self, message: types.Message):
        return await self.abc_roll_stats_round(
            stats_func=self.board.current_stats,
            header='*–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—É–Ω–¥–∞*',
            message=message,
        )

    @async_log_exception
    async def roll_stats_total(self, message: types.Message):
        return await self.abc_roll_stats_round(
            stats_func=self.board.total_stats,
            header='*–õ—É—á—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∑–∞ —Å—É—Ç–∫–∏*',
            message=message,
        )

    @async_log_exception
    async def show_user_info(self, message: types.Message):
        text = [
            '*–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ*',
            '',
            f'–ò–º—è: `{message.chat.full_name}`',
            f'–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞: `{message.chat.id}`',
        ]
        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )

    @async_log_exception
    async def show_help(self, message: types.Message):
        text = [
            '*–ë–æ—É–ª–∏–Ω–≥*',
            '',
            f'/{COMMAND_ROLL} -- –±—Ä–æ—Å–∏—Ç—å —à–∞—Ä—ã.',
            f'/{COMMAND_ROUND_LEADERS} -- –∏—Ç–æ–≥–∏ —Ä–∞—É–Ω–¥–∞.',
            f'/{COMMAND_GAME_LEADERS} -- –ª—É—á—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.',
            '',
            '*–ü–æ–º–æ—â—å*',
            '',
            f'/{COMMAND_START} -- –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞.',
            f'/{COMMAND_HELP} -- –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –µ—â—ë —Ä–∞–∑.',
            f'–ó–∞–¥–∞–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å: /{COMMAND_QUESTION} –í–∞—à –≤–æ–ø—Ä–æ—Å.',
        ]
        if message.chat.id in ADMIN_IDS:
            text.extend([
                '',
                '*–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã*',
                '',
                f'/{COMMAND_LAUNCH_SECONDS} -- –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ä–∞—É–Ω–¥ –Ω–∞ x —Å–µ–∫—É–Ω–¥.',
                f'/{COMMAND_LAUNCH_TIME} -- –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ä–∞—É–Ω–¥ —Å HH:MM –ø–æ HH:MM.',
                f'/{COMMAND_PRIZE} -- –ó–∞–¥–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–∑–æ–≤—ã—Ö –º–µ—Å—Ç (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é - 5).',
                f'/{COMMAND_USER} -- –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —Å–µ–±—è.',
                f'/{COMMAND_STATS} -- –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –±–æ—Ç–∞.',
            ])
        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )

    @async_log_exception
    async def launch_bot_seconds(self, message: types.Message):  # –ó–∞–ø—É—Å–∫ —Å—Ä–∞–∑—É –Ω–∞ n —Å–µ–∫—É–Ω–¥, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö —Ç–µ—Å—Ç–æ–≤
        global duration, launched
        duration = int(message.get_args())
        launched = True
        self.board.run_update(d=duration)
        text = [
            f'–†–∞—É–Ω–¥ –∑–∞–ø—É—â–µ–Ω –Ω–∞ {duration} —Å–µ–∫—É–Ω–¥!'
        ]
        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )
        await self.time_out_check(d=duration, message=message)

    @async_log_exception
    async def launch_bot_time(self, message: types.Message):  # –ó–∞–ø—É—Å–∫ —Å XX:YY –ø–æ ZZ:AA —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è
        global duration, launched
        current_time = datetime.datetime.now()
        t = str(message.get_args())
        start_hour = int(t[:2])
        start_minute = int(t[3:5])
        stop_hour = int(t[6:8])
        stop_minute = int(t[9:11])
        start_time = datetime.datetime(datetime.datetime.now().year, datetime.datetime.now().month,
                                       datetime.datetime.now().day, start_hour, start_minute)
        stop_time = datetime.datetime(datetime.datetime.now().year, datetime.datetime.now().month,
                                      datetime.datetime.now().day,  stop_hour, stop_minute)
        delta = (start_time - current_time).seconds
        await asyncio.sleep(delta)
        launched = True
        duration = (stop_time - start_time).seconds
        self.board.run_update(d=duration)
        text = [
            f'–†–∞—É–Ω–¥ –∑–∞–ø—É—â–µ–Ω —Å {start_time} –ø–æ {stop_time}'
        ]
        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )
        await self.time_out_check(d=duration, message=message)

#    –ü–æ–ø—ã—Ç–∫–∞ —Å–¥–µ–ª–∞—Ç—å –∫–Ω–æ–ø–∫–∏
#    @async_log_exception
#    async def launch_bot_timestart(self, message: types.Message):
#        current_hour = datetime.datetime.now().time().hour
#        keyboard = types.InlineKeyboardMarkup()
#        for i in range(8):
#            times.append((current_hour + 1 + i) % 24)
#            keyboard.add(types.InlineKeyboardButton(text=f"{times[i]}:00", callback_data=f"button{i + 1}"))
#        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ —Ä–∞—É–Ω–¥–∞", reply_markup=keyboard)
    @async_log_exception
    async def time_out_check(self, d, message: types.Message):
        await asyncio.sleep(d)
        text = [
            "–†–∞—É–Ω–¥ –æ–∫–æ–Ω—á–µ–Ω!",

            "–°–ø–∞—Å–∏–±–æ –∑–∞ —É—á–∞—Å—Ç–∏–µ"
        ]
        for msg in messages:  # –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Ä–∞—É–Ω–¥–∞
            await m.bot.send_message(chat_id=msg.chat.id, text=prepare_str(text=text))
            await self.roll_stats_round(message=msg)
        await self.przies()

    @async_log_exception
    async def set_prizewinners(self, message: types.Message):
        global prizewinners
        prizewinners = int(message.get_args())
        text = [
            f'–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–∑–æ–≤—ã—Ö –º–µ—Å—Ç: {prizewinners}'
        ]
        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )

    @async_log_exception
    async def przies(self):
        leaders = self.board.get_leads()[:prizewinners]
        for i in range(len(leaders)):
            text = [
                f"–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –∑–∞–Ω—è–ª–∏ {i + 1} –º–µ—Å—Ç–æ!",

                "–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–∏–∑–∞ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—Ç—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É —Å–æ–æ–±—â–µ—Å—Ç–≤–∞."
            ]
            await m.bot.send_message(chat_id=leaders[i].chat_id, text=prepare_str(text=text))

    @async_log_exception
    async def show_stats(self, message: types.Message):
        if not self.func_counter:
            return await message.answer(
                text='–°–µ–π—á–∞—Å —Ç—É—Ç –Ω–∏—á–µ–≥–æ –Ω–µ—Ç.',
            )

        now = time.time()
        lifetime = pretty_time_delta(now - self.started_at)

        text = [
            '*–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞*',
            '',
            f'- –í—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å –º–æ–º–µ–Ω—Ç–∞ —Å—Ç–∞—Ä—Ç–∞: *{self.counter}*',
            f'- –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –º–æ–º–µ–Ω—Ç–∞ —Å—Ç–∞—Ä—Ç–∞: *{len(self.unique_chats)}*',
            f'- –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ –±–æ—Ç–∞: {lifetime}',
            '',
            '*–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ñ—É–Ω–∫—Ü–∏—è–º*',
            '',
        ]
        total_resp_time = []
        sorted_requests = sorted(self.func_counter.items(), key=lambda i: (i[1], i[0]), reverse=True)
        for (fn, requests) in sorted_requests:
            # AVG resp time
            resp_time = self.func_resp_time[fn]
            total_resp_time.extend(resp_time)
            avg_resp = sum(resp_time) / len(resp_time)

            text.append(f'`{fn}`')
            text.append(f'{requests} requests, {avg_resp:.0f} avg resp time (ms)')
            text.append('')

        # –í—Å—Ç–∞–≤–∏—Ç—å –ø–æ—Å–ª–µ ``–í—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤..``
        total_avg = sum(total_resp_time) / len(total_resp_time)
        text.insert(3, f'- –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞: *{total_avg:.0f}* (ms)')

        await message.answer(
            text=prepare_str(text=text),
            parse_mode=types.ParseMode.MARKDOWN,
        )


if __name__ == '__main__':
    # TG_TOKEN = os.getenv('TG_TOKEN')
    TG_TOKEN = API_TOKEN
    assert TG_TOKEN, 'TG_TOKEN env variable must be set!'

    SENTRY_TOKEN = os.getenv('SENTRY_TOKEN')

    m = Manager(
        token=TG_TOKEN,
    )
    m.run()
